---
title: "Sample Integration Report"
author: "CCBR"
date: '`r format(Sys.time(), "%a %b %d %Y - %X")`'
output:
  html_document: default
params:
  gid: "text"
  mergedObj: "/data/sevillas2/scRNA_test/seurat/merge/group1-group2_seurat_merged.rds"
  CCAintegratedObj: "/data/sevillas2/scRNA_test/batch_correct/group1-group2_batchcorrection_cca.rds"
  rpcaObj: "/data/sevillas2/scRNA_test/batch_correct/group1-group2_batchcorrection_rpca.rds"
  harmonyObj: "/data/sevillas2/scRNA_test/batch_correct/group1-group2_batchcorrection_harmony.rds"
  resolution_list: "0.1,0.2,0.3,0.5,0.6,0.8,1"
  citeseq: "text"
  annot: "text"
  imageDir: "path/to/images"
  Rlib_dir: "/data/CCBR_Pipeliner/db/PipeDB/Rlibrary_4.3_scRNA_RHEL8"
  Rpkg_config: "/data/CCBR_Pipeliner/Pipelines/TechDev_scRNASeq_Dev2023/SINCLAIR/conf/Rpack.config"
  scRNA_functions: "/data/CCBR_Pipeliner/Pipelines/TechDev_scRNASeq_Dev2023/SINCLAIR/bin/scRNA_functions.R"
  testing: "Y"
geometry:
  margins:0.25in
editor_options: 
  chunk_output_type: console
---

```{r, prep_args,  message=FALSE, echo=FALSE, include=FALSE}
# set up params
#species= params$species
gid = params$gid
mergedObj=params$mergedObj
CCAintegratedObj=params$CCAintegratedObj
rpcaObj=params$rpcaObj
harmonyObj=params$harmonyObj

resolution=as.numeric(strsplit(params$resolution_list,",")[[1]])
citeseq=params$citeseq
annot=params$annot

imageDir=params$imageDir

Rlib_dir=params$Rlib_dir
Rpkg_config=params$Rpkg_config
scRNA_functions = params$scRNA_functions
```

```{r, handle_pkg, message=FALSE, echo=FALSE, include=FALSE}
# set library dir, load this and remove any other dirs to avoid confusion
# between personally created pkgs and the pipeline package
## saving old path "/Library/Frameworks/R.framework/Versions/4.2-arm64/Resources/library"
print(paste0("Using the lib.loc location: ",Rlib_dir))
assign(".lib.loc", Rlib_dir, envir = environment(.libPaths))
.libPaths()

# read in package info
pkg_df=read.csv(Rpkg_config)
pkg_df=subset(pkg_df,int=="Y")
pkg_df

# for each package check installation, if present then load library
for (rowid in rownames(pkg_df)){
  pkg=pkg_df[rowid,"package"]
  source=pkg_df[rowid,"source"]
  version=pkg_df[rowid,"version"]
  gh_name=pkg_df[rowid,"gh_name"]

  need_install <- pkg[!(pkg %in% installed.packages()[,"Package"])]
  if (length(need_install)!=0){
    print(paste0("Installing: ", pkg))
    if (source=="bc") BiocManager::install(pkg)
    if (source=="cr") install.packages(pkg,version=version,repos = "http://cran.us.r-project.org",
                                       local = FALSE)
    if (source=="gh") remotes::install_github(gh_name,version=version,local = FALSE)
  }

  print(paste0("Loading: ",pkg))
  invisible(lapply(pkg, library, character.only = TRUE))
}

# source functions
source(scRNA_functions)

# additional options
#tinytex::install_tinytex(force = TRUE)
```

```{r removelibraryImport, echo=FALSE, message=FALSE, warning=FALSE}
# path = dirname(params$imageDir)
# require("knitr")
# knitr::opts_chunk$set(
# 	echo = FALSE,
# 	message = FALSE,
# 	warning = FALSE
# )
# knitr::opts_knit$set(
#   root.dir=path
# )
# 
# .libPaths("/data/CCBR_Pipeliner/db/PipeDB/")
# .libPaths("/data/CCBR_Pipeliner/db/PipeDB/scrna4.2Rlibs")
# 
# #Visualization libraries
# library(magick)
# library(cowplot)
# library(scales)
# library(RColorBrewer)

# 
# #Bioconductor dependencies
# library(BiocGenerics)
# library(Biobase)
# library(farver)
# library(S4Vectors)
# library(AnnotationDbi)
# library(dplyr)
# library(Matrix)
# library(reshape2)
# library(tools)
# library(stringr)
# 
# #statistics libraries
# library(VennDiagram)
# library(cluster)
# library(DT)
# 
# #scRNASeq libraries
# library(scRNAseq)
# library(SingleCellExperiment)
# library(SingleR)
# library(scater)
# library(DoubletFinder)
# library(celldex)
```

```{r, processing, message=FALSE, echo=FALSE, include=FALSE}
# read in merged objects
so_merged_raw = readRDS(mergedObj)
so_rpca = readRDS(rpcaObj)
so_harmony = readRDS(harmonyObj)
so_integrated = readRDS(CCAintegratedObj)

# identify object list
objList = c("rpca","merged","CCAintegrated","harmony")
```

```{r mergedObjDims,message=FALSE, echo=FALSE, include=FALSE}
# add reduction methods to the mergedObj for plotting
so_merged <- ScaleData(so_merged_raw, vars.to.regress = c("percent_mito", "nFeature_RNA"), assay = "RNA")
so_merged <- RunPCA(so_merged, npcs = 50, verbose = F)
so_merged <- RunTSNE(so_merged, reduction = "pca", dims = 1:30, perplexity = 30, max_iter = 1000,
                   theta = 0.5, eta = 200, num_threads = 0)
so_merged <- RunUMAP(so_merged, reduction = "pca", dims = 1:30, n.components = 2, n.neighbors = 30,
                   n.epochs = 200, min.dist = 0.3, learning.rate = 1, spread = 1)
```


## **Batch correction selection**

### DimPlots {.tabset}

#### Samples

```{r sampleBatchCorrection, echo=FALSE, fig.width=15, fig.height=15}
# identify object list
objList = c("merged","rpca","integrated","harmony")

# plot 
for(i in 1:length(objList)){
  obj = OBJECT_SELECT(objList[i])
  title = NAME_SELECT(objList[i])
  sampleImage = DimPlot(obj,group.by="Sample",pt.size = 0.01) + 
    ggtitle(title)+
    theme(legend.position="bottom",
          legend.text=element_text(size=12))+
    guides(colour=guide_legend(ncol=6,override.aes = list(size=3)))
  assign(x=paste0("s",i),value=sampleImage)
}
p = ggarrange(s1,s2,s3,s4,
          ncol=2,nrow=2,
          common.legend=T,
          legend="bottom")

annotate_figure(p,
                top = text_grob("Batch Correction Methods\n by Sample", 
                                color = "red", face = "bold", size = 14))
```

#### Groups

```{r groupBatchCorrection, echo=FALSE, fig.width=15, fig.height=15}
for(i in 1:length(objList)){
  obj = OBJECT_SELECT(objList[i])
  title = NAME_SELECT(objList[i])
  sampleImage = DimPlot(obj,group.by="Group",raster=F, pt.size= 0.001) + 
    ggtitle(title)+
    theme(legend.position="bottom",legend.text=element_text(size=12))+
    guides(colour=guide_legend(override.aes = list(size=3)))
  assign(x=paste0("g",i),value=sampleImage)
}
p = ggarrange(g1,g2,g3,g4,
          ncol=2,nrow=2,
          common.legend=T,
          legend="bottom")

annotate_figure(p,
                top = text_grob("Batch Correction Methods\n by Groups", 
                                color = "red", face = "bold", size = 14))
```

#### Cell type annotations

```{r annotationBatchCorrection, echo=FALSE, fig.width=15, fig.height=15}
for(i in 1:length(objList)){
  obj = OBJECT_SELECT(objList[i])
  title = NAME_SELECT(objList[i])
  sampleImage = DimPlot(obj,group.by="annot") +
    ggtitle(title)+
    theme(legend.position="bottom",legend.text=element_text(size=12))+
    guides(colour=guide_legend(ncol=6,override.aes = list(size=3)))
  assign(x=paste0("c",i),value=sampleImage)
}
p = ggarrange(c1,c2,c3,c4,
          ncol=2,nrow=2,
          common.legend=T,legend="bottom")

annotate_figure(p,
                top = text_grob("Batch Correction Methods\n by Primary Annotation", 
                                color = "red", face = "bold", size = 14))

DT::datatable(as.data.frame.matrix(cbind(table(so_merged$annot,
                                           so_merged$Sample),table(so_merged$annot))),
          colnames=c(unique(so_merged$Sample),"Total"))
```

### Silhouette scores  {.tabset}

```{r silhouetteImages,  echo=FALSE, include=FALSE}
# create matrix
resSil_merged=matrix(ncol=2,nrow=length(resolution))
resSil_merged[]<-0
resSil_integrated=resSil_merged
resSil_rpca=resSil_merged
resSil_harmonyGroup=resSil_merged
resSil_harmonySample=resSil_merged

# Initial loop through integration methods
for(i in 1:length(objList)){
  obj = OBJECT_SELECT(objList[i])

  # Initialize silhouette scores matrix
  resSil_mat = matrix(ncol=2,nrow=length(resolution))
  resSil_mat[,1]<- as.numeric(resolution)
  resSil_mat[,2]<-0
  
  # TBD
  k=1

  # Skip all calculations for objects greater than 90k cells
  if(ncol(obj)<90000){
    
    # if batch correction is harmony, use harmony reduction
    # otherwise use PCA
    if(length(grep("^harmony",objList[i]))){
      dist = dist(Embeddings(obj,reduction='harmony')[,1:30])
    } else{
      dist = dist(Embeddings(obj,reduction='pca')[,1:30])
    }
    
    # iterate each resolution value
    for (res in resolution){
      #convert resolution to numeric value
      resMod=as.numeric(res)
      
      #SLM name identity determination, based on integration method
      slm_name = grep("^SLM",colnames(obj@meta.data),value=T)
      if (objList[i] %in% c("integrated","rpca")){
        slm_name=gsub("\\..*","",grep("int",slm_name,value=T)[1])
      } else{
        slm_name=gsub("\\..*","",grep("SCT",slm_name,value=T)[1])
      }
      
      # create file for resolution and integration method
      fileName = paste0("silhouetteResolution_",res,"_",objList[[i]],".pdf")
      pdf(fileName)

      if ((slm_name %in% colnames(obj@meta.data))==FALSE){
        obj = FindClusters(obj, algorithm =3, resolution = resMod)
        obj[[slm_name]] = Idents(obj)
        rdsFile = params[[grep(objList[k],names(params),value=T)]]
        saveRDS(obj,file=rdsFile)
        message(paste(objList[k],
                      "object has been overwritten to include clustering at resolution",
                      res))
      }

      #Calculate silhouette scores for resolutions with more than one cluster
      Idents(obj)=slm_name
      clusters=Idents(obj)

      if(length(unique(clusters))==1){ #edge case of failed sample, only one cluster
        plot.new()
        text(0.5,0.5,"No silhouette available for single cluster samples")
        dev.off()
      } else{
        sil=silhouette(as.numeric(as.character(clusters)),dist=dist)
        palette=alpha(colour=hue_pal()(length(unique(Idents(obj)))),alpha=0.7)

        #Export silhouette plot to file
        print(plot(sil, col=palette[as.factor(clusters[order(as.numeric(as.character(clusters)),
                                                             decreasing=F)])],
        main=paste0("Silhouette plot of clustering resolution ", res), lty=2,
        sub=paste("Average silhouette width:",format(round(mean(sil[,3]), 4), nsmall = 4))))
        abline(v=mean(sil[,3]), col="red4", lty=2)
        dev.off()

        #Store resolution vs average silhouette score
        resSil_mat[i,2] = format(round(mean(sil[,3]), 4), nsmall = 4)
      }
      i=i+1
    }
  } else{
    for (res in resolution){
      fileName = paste0("silhouetteResolution_",res,"_",objList[i],".pdf")
      pdf(fileName)
      plot.new()
      text(0.5,0.5,"No silhouette available for datasets with more than 90,000 cells")
      dev.off()
    }
  }
  #Convert character matrix to numeric matrix and assign to appropriate variable
  resSil_mat = matrix(as.numeric(resSil_mat),ncol=ncol(resSil_mat))
  assign(x=paste0("resSil_",objList[k]),value=resSil_mat)
}


```

<!-- ### Clustering -->

<!-- #### Merged {.tabset} -->

<!-- ```{r clusterResultsMerged,fig.width=15, fig.height=9, echo=FALSE, results="asis"} -->
<!-- for (res in resolution){ -->
<!--   resMod = as.numeric(res) -->
<!--   fileName = paste0(params$imageDir,"/silhouetteResolution_",res,"_merged.pdf") -->
<!--   cat("  \n##### Clustering at Resolution ", res," \n") -->
<!--   clusterPlot = DimPlot(merged, group.by=paste0("SLM_SCT_snn_res.",resMod), -->
<!--                         label=T,repel=T, -->
<!--     order=sort(as.numeric(as.character(unique(merged[[paste0("SLM_SCT_snn_res.",resMod)]][,1]))), -->
<!--                decreasing=T))+ -->
<!--     ggtitle(paste("Merged clusters at resolution",res)) -->
<!--   p1 = ggdraw(clusterPlot) -->
<!--   p2 = ggdraw()+draw_image(fileName) -->
<!--   print(plot_grid(p1,p2)) -->
<!--   cat("  \n") -->
<!-- } -->

<!-- cat("  \n##### Average silhouette scores vs clustering resolution \n") -->
<!-- plot(resSil_merged,lty=3,pch=1,type="b", -->
<!--      lwd=2,cex=3, -->
<!--      main="Average silhouette score vs clustering resolution", -->
<!--      xlab = "Resolution", ylab="Average Silhouette Score", -->
<!--      xlim=c(min(resSil_merged[,1])-0.1,max(resSil_merged[,1])+0.1), -->
<!--      ylim=c(round(min(resSil_merged[,2])-0.005,digits=3), -->
<!--             round(max(resSil_merged[,2])+0.005,digits=3))) -->
<!-- cat("  \n") -->
<!-- ``` -->

<!-- #### CCA Integration {.tabset} -->
<!-- ```{r clusterIntegrated, fig.width=15, fig.height=9, echo=FALSE, results="asis"} -->
<!-- for (res in resolution){ -->
<!--   resMod = as.numeric(res) -->
<!--   fileName = paste0(params$imageDir,"/silhouetteResolution_",res,"_integrated.pdf") -->
<!--   cat("  \n##### Clustering at Resolution ", res," \n") -->
<!--   clusterPlot = DimPlot(integrated, group.by=paste0("SLM_int_snn_res.",resMod), -->
<!--                         label=T,repel=T, -->
<!--     order=sort(as.numeric(as.character(unique(integrated[[paste0("SLM_int_snn_res.",resMod)]][,1]))), -->
<!--                decreasing=T))+ -->
<!--     ggtitle(paste("Integrated clusters at resolution",res)) -->
<!--   p1 = ggdraw(clusterPlot) -->
<!--   p2 = ggdraw()+draw_image(fileName) -->
<!--   print(plot_grid(p1,p2)) -->
<!--   cat("  \n") -->
<!-- } -->

<!-- cat("  \n##### Average silhouette scores vs clustering resolution \n") -->
<!-- plot(resSil_integrated,lty=3,pch=1,type="b",lwd=2,cex=3, -->
<!--   main="Average silhouette score vs clustering resolution", -->
<!--   xlab = "Resolution", ylab="Average Silhouette Score", -->
<!--   xlim=c(min(resSil_integrated[,1])-0.1,max(resSil_integrated[,1])+0.1), -->
<!--   ylim=c(round(min(resSil_integrated[,2])-0.005,digits=3), -->
<!--          round(max(resSil_integrated[,2])+0.005,digits=3))) -->
<!-- cat("  \n") -->
<!-- ``` -->

<!-- #### Harmony (by sample ID) {.tabset} -->
<!-- ```{r clusterHarmonySample, fig.width=15, fig.height=9, echo=FALSE, results="asis"} -->
<!-- for (res in resolution){ -->
<!--   resMod = as.numeric(res) -->
<!--   fileName = paste0(params$imageDir,"/silhouetteResolution_",res,"_harmonySample.pdf") -->
<!--   cat("  \n##### Clustering at Resolution ", res," \n") -->
<!--   clusterPlot = DimPlot(harmonySample, -->
<!--                         group.by=paste0("SLM_SCT_snn_res.",resMod), -->
<!--                         label=T,repel=T, -->
<!--     order=sort(as.numeric(as.character(unique(harmonySample[[paste0("SLM_SCT_snn_res.", -->
<!--                                                                     resMod)]][,1]))), -->
<!--                decreasing=T))+ -->
<!--     ggtitle(paste("Harmony (sample) clusters at resolution",res)) -->
<!--   p1 = ggdraw(clusterPlot) -->
<!--   p2 = ggdraw()+draw_image(fileName) -->
<!--   print(plot_grid(p1,p2)) -->
<!--   cat("  \n") -->
<!-- } -->

<!-- cat("  \n##### Average silhouette scores vs clustering resolution \n") -->
<!-- plot(resSil_harmonySample,lty=3,pch=1,type="b", -->
<!--      lwd=2,cex=3, -->
<!--   main="Average silhouette score vs clustering resolution", -->
<!--   xlab = "Resolution", ylab="Average Silhouette Score", -->
<!--   xlim=c(min(resSil_harmonySample[,1])-0.1, -->
<!--          max(resSil_harmonySample[,1])+0.1), -->
<!--   ylim=c(round(min(resSil_harmonyGroup[,2])-0.005,digits=3), -->
<!--          round(max(resSil_harmonySample[,2])+0.005,digits=3))) -->
<!-- cat("  \n") -->
<!-- ``` -->

<!-- #### rPCA {.tabset} -->
<!-- ```{r clusterRPCA, fig.width=15, fig.height=9, echo=FALSE, results="asis"} -->
<!-- for (res in resolution){ -->
<!--   resMod = as.numeric(res) -->
<!--   fileName = paste0(params$imageDir,"/silhouetteResolution_", -->
<!--                     res,"_rpca.pdf") -->
<!--   cat("  \n##### Clustering at Resolution ", res," \n") -->
<!--   clusterPlot = DimPlot(rpca, group.by=paste0("SLM_int_snn_res.",resMod), -->
<!--                         label=T,repel=T, -->
<!--     order=sort(as.numeric(as.character(unique(rpca[[paste0("SLM_int_snn_res.", -->
<!--                                                            resMod)]][,1]))),decreasing=T))+ -->
<!--     ggtitle(paste("RPCA clusters at resolution",res)) -->
<!--   p1 = ggdraw(clusterPlot) -->
<!--   p2 = ggdraw()+draw_image(fileName) -->
<!--   print(plot_grid(p1,p2)) -->
<!--   cat("  \n") -->
<!-- } -->

<!-- cat("  \n##### Average silhouette scores vs clustering resolution \n") -->
<!-- plot(resSil_rpca,lty=3,pch=1,type="b",lwd=2,cex=3, -->
<!--   main="Average silhouette score vs clustering resolution", -->
<!--   xlab = "Resolution", ylab="Average Silhouette Score", -->
<!--   xlim=c(min(resSil_rpca[,1])-0.1,max(resSil_rpca[,1])+0.1), -->
<!--   ylim=c(round(min(resSil_rpca[,2])-0.005,digits=3),round(max(resSil_rpca[,2])+0.005, -->
<!--                                                           digits=3))) -->
<!-- cat("  \n") -->
<!-- ``` -->
